To index a field that holds an array value, MongoDB creates an index key for each element in the array. These multikey indexes support efficient queries against array fields. Multikey indexes can be constructed over arrays that hold both scalar values [1] (e.g. strings, numbers) and nested documents.
要索引保存数组值的字段，MongoDB为数组中的每个元素创建索引键。这些多键索引支持对数组字段的高效查询。多键索引可以在包含标量值【1】（例如字符串、数字）和嵌套文档的数组上构建。

Create Multikey Index
To create a multikey index, use the db.collection.createIndex() method:
db.coll.createIndex( { <field>: < 1 or -1 > } )
MongoDB automatically creates a multikey index if any indexed field is an array; you do not need to explicitly specify the multikey type.
如果任何索引字段是数组，MongoDB会自动创建多键索引；您不需要显式指定多键类型。

Index Bounds索引边界

Unique Multikey Index单多键索引
For unique indexes, the unique constraint applies across separate documents in the collection rather than within a single document.
对于唯一索引，唯一约束应用于集合中的单独文档，而不是在单个文档中。
Because the unique constraint applies to separate documents, for a unique multikey index, a document may have array elements that result in repeating index key values as long as the index key values for that document do not duplicate those of another document.
由于唯一约束适用于单独的文档，因此对于唯一的多键索引，只要该文档的索引键值不重复另一个文档的索引键值，文档就可能具有导致重复索引键值的数组元素。

Limitations限制条件

Compound Multikey Indexes复合多键索引
For a compound multikey index, each indexed document can have at most one indexed field whose value is an array. That is:
对于复合多键索引，每个索引文档最多可以有一个索引字段，其值为数组。那就是：
You cannot create a compound multikey index if more than one to-be-indexed field of a document is an array. For example, consider a collection that contains the following document:
如果文档的多个要索引的字段是数组，则无法创建复合多键索引。例如，考虑包含以下文档的集合：
{ _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: "AB - both arrays" }
You cannot create a compound multikey index { a: 1, b: 1 } on the collection since both the a and b fields are arrays.
无法在集合上创建复合多键索引{ a: 1, b: 1 }，因为a和b字段都是数组。

Or, if a compound multikey index already exists, you cannot insert a document that would violate this restriction.
或者，如果复合多键索引已存在，则不能插入违反此限制的文档。

Consider a collection that contains the following documents:
{ _id: 1, a: [1, 2], b: 1, category: "A array" }
{ _id: 2, a: 1, b: [1, 2], category: "B array" }
A compound multikey index { a: 1, b: 1 } is permissible since for each document, only one field indexed by the compound multikey index is an array; i.e. no document contains array values for both a and b fields.
允许复合多键索引{ a: 1, b: 1 }，因为对于每个文档，只有一个由复合多键索引索引的字段是数组；即，没有文档包含a和b字段的数组值。
However, after creating the compound multikey index, if you attempt to insert a document where both a and b fields are arrays, MongoDB will fail the insert.
但是，在创建复合多键索引后，如果尝试插入a和b字段都是数组的文档，MongoDB将无法插入。

If a field is an array of documents, you can index the embedded fields to create a compound index. For example, consider a collection that contains the following documents:
如果字段是文档数组，则可以对嵌入的字段进行索引以创建复合索引。例如，考虑包含以下文档的集合：
{ _id: 1, a: [ { x: 5, z: [ 1, 2 ] }, { z: [ 1, 2 ] } ] }
{ _id: 2, a: [ { x: 5 }, { z: 4 } ] }
You can create a compound index on { "a.x": 1, "a.z": 1 }. The restriction where at most one indexed field can be an array also applies.
您可以在{ "a.x": 1, "a.z": 1 }上创建复合索引。最多一个索引字段可以是数组的限制也适用。

Sorting
As a result of changes to sorting behavior on array fields in MongoDB 3.6, when sorting on an array indexed with a multikey index the query plan includes a blocking SORT stage. The new sorting behavior may negatively impact performance.
由于MongoDB 3.6中数组字段排序行为的更改，当对使用多键索引索引的数组进行排序时，查询计划包括阻塞排序阶段。新的排序行为可能会对性能产生负面影响。
In a blocking SORT, all input must be consumed by the sort step before it can produce output. In a non-blocking, or indexed sort, the sort step scans the index to produce results in the requested order.
在阻塞排序中，排序步骤必须消耗所有输入，然后才能产生输出。在非阻塞或索引排序中，排序步骤扫描索引以按请求的顺序生成结果。

Shard Keys
You cannot specify a multikey index as the shard key index.
不能将多键索引指定为分片键索引。
However, if the shard key index is a prefix of a compound index, the compound index is allowed to become a compound multikey index if one of the other keys (i.e. keys that are not part of the shard key) indexes an array. Compound multikey indexes can have an impact on performance.
但是，如果分片键索引是复合索引的前缀，则如果其他键之一（即不属于分片键的键）索引数组，则允许复合索引成为复合多键索引。复合多键索引可能会对性能产生影响。

Hashed Indexes
Hashed indexes cannot be multikey.

Query on the Array Field as a Whole
When a query filter specifies an exact match for an array as a whole, MongoDB can use the multikey index to look up the first element of the query array but cannot use the multikey index scan to find the whole array. Instead, after using the multikey index to look up the first element of the query array, MongoDB retrieves the associated documents and filters for documents whose array matches the array in the query.
当查询筛选器指定数组作为一个整体的精确匹配时，MongoDB可以使用多键索引查找查询数组的第一个元素，但不能使用多键索引扫描查找整个数组。相反，在使用多键索引查找查询数组的第一个元素后，MongoDB检索关联的文档，并筛选其数组与查询中数组匹配的文档。
For example, consider an inventory collection that contains the following documents:
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ] }
{ _id: 6, type: "food", item: "bbb", ratings: [ 5, 9 ] }
{ _id: 7, type: "food", item: "ccc", ratings: [ 9, 5, 8 ] }
{ _id: 8, type: "food", item: "ddd", ratings: [ 9, 5 ] }
{ _id: 9, type: "food", item: "eee", ratings: [ 5, 9, 5 ] }
The collection has a multikey index on the ratings field:
db.inventory.createIndex( { ratings: 1 } )
The following query looks for documents where the ratings field is the array [ 5, 9 ]:
db.inventory.find( { ratings: [ 5, 9 ] } )
MongoDB can use the multikey index to find documents that have 5 at any position in the ratings array. Then, MongoDB retrieves these documents and filters for documents whose ratings array equals the query array [ 5, 9 ].
MongoDB可以使用多键索引查找在评级数组中任何位置具有5的文档。然后，MongoDB检索这些文档，并筛选其评级数组等于查询数组【5,9】的文档。

$expr
$expr does not support multikey indexes.



Examples
Index Basic Arrays
Consider a survey collection with the following document:
{ _id: 1, item: "ABC", ratings: [ 2, 5, 9 ] }
Create an index on the field ratings:
db.survey.createIndex( { ratings: 1 } )
Since the ratings field contains an array, the index on ratings is multikey. The multikey index contains the following three index keys, each pointing to the same document:
由于评级字段包含数组，因此评级索引是多键的。多键索引包含以下三个索引键，每个索引键都指向同一文档：
2,
5, and
9.

Index Arrays with Embedded Documents带嵌入式文档的索引数组
You can create multikey indexes on array fields that contain nested objects.您可以在包含嵌套对象的数组字段上创建多键索引。
Consider an inventory collection with documents of the following form:
{
  _id: 1,
  item: "abc",
  stock: [
    { size: "S", color: "red", quantity: 25 },
    { size: "S", color: "blue", quantity: 10 },
    { size: "M", color: "blue", quantity: 50 }
  ]
}
{
  _id: 2,
  item: "def",
  stock: [
    { size: "S", color: "blue", quantity: 20 },
    { size: "M", color: "blue", quantity: 5 },
    { size: "M", color: "black", quantity: 10 },
    { size: "L", color: "red", quantity: 2 }
  ]
}
{
  _id: 3,
  item: "ijk",
  stock: [
    { size: "M", color: "blue", quantity: 15 },
    { size: "L", color: "blue", quantity: 100 },
    { size: "L", color: "red", quantity: 25 }
  ]
}

...

The following operation creates a multikey index on the stock.size and stock.quantity fields:
db.inventory.createIndex( { "stock.size": 1, "stock.quantity": 1 } )
The compound multikey index can support queries with predicates that include both indexed fields as well as predicates that include only the index prefix "stock.size", as in the following examples:
复合多键索引可以支持包含索引字段的谓词以及仅包含索引前缀“股票.size”的谓词的查询，如以下示例所示：
db.inventory.find( { "stock.size": "M" } )
db.inventory.find( { "stock.size": "S", "stock.quantity": { $gt: 20 } } )

The compound multikey index can also support sort operations, such as the following examples:
复合多键索引还可以支持排序操作，例如以下示例：
db.inventory.find( ).sort( { "stock.size": 1, "stock.quantity": 1 } )
db.inventory.find( { "stock.size": "M" } ).sort( { "stock.quantity": 1 } )












